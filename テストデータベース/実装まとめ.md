# Mifareカード読み取りシステム - 実装まとめ

## プロジェクト概要

PaSoRi 4.0（SONY FeliCa Port/PaSoRi 4.0）を使用してMifareカードの番号を読み取り、SQLiteデータベースに保存するシステムを実装しました。

## 実装の経緯

### 最初のアプローチ: Python版（nfcpy）

最初はPythonの`nfcpy`ライブラリを使用して実装を試みましたが、macOS Sequoia（26.2）での動作に問題が発生しました。

**発生した問題:**
1. `libusb-1.0`が見つからないエラー
2. `Operation not supported by device`エラー
3. macOSのセキュリティ設定によるUSBデバイスアクセスの制限

**解決策:**
- `libusb`と`libnfc`をHomebrewでインストール
- 環境変数`DYLD_LIBRARY_PATH`の設定
- システム環境設定での権限設定

しかし、macOS Sequoiaでの互換性問題により、Node.js版への移行を決定しました。

### 最終的なアプローチ: Node.js版（pcsclite）

Node.jsと`pcsclite`ライブラリを使用することで、PC/SC経由でPaSoRiリーダーにアクセスできるようになりました。

## システム構成

### 使用技術

- **言語**: Node.js (v24.12.0)
- **ライブラリ**:
  - `pcsclite`: PC/SC経由でカードリーダーにアクセス
  - `sqlite3`: SQLiteデータベース操作
- **ハードウェア**: PaSoRi 4.0（SONY FeliCa Port/PaSoRi 4.0）
- **OS**: macOS Sequoia (26.2)

### ファイル構成

```
テストデータベース/
├── main.js              # メインアプリケーション
├── card_reader.js       # カード読み取り機能
├── database.js          # データベース操作機能
├── package.json         # Node.jsパッケージ設定
├── cards.db             # SQLiteデータベース（自動生成）
├── main.py              # Python版（参考用）
├── card_reader.py       # Python版（参考用）
├── database.py          # Python版（参考用）
└── README.md            # 使用方法
```

## セットアップ手順

### 1. 必要なソフトウェアのインストール

#### Node.jsとnpm
```bash
# Homebrewでインストール（既にインストール済みの場合を除く）
brew install node
```

#### PC/SCライブラリ
```bash
brew install pcsc-lite
```

#### PC/SCサービスの起動確認
```bash
brew services list | grep pcsc
# 起動していない場合
brew services start pcsc-lite
```

### 2. プロジェクトのセットアップ

```bash
# プロジェクトディレクトリに移動
cd "/Users/k.muto/webapp_01/テストデータベース"

# Node.jsパッケージをインストール
npm install
```

**インストールされるパッケージ:**
- `pcsclite`: PC/SC経由でカードリーダーにアクセス
- `sqlite3`: SQLiteデータベース操作

### 3. 権限設定（macOS）

#### システム環境設定での権限設定

1. **システム環境設定**を開く
2. **セキュリティとプライバシー** > **プライバシー**を選択
3. **完全なディスクアクセス**にターミナルアプリを追加
4. ターミナルを再起動

#### npmの権限エラーが発生した場合

```bash
# npmキャッシュをクリア
npm cache clean --force

# 再度インストール
npm install
```

## カード読み取りの仕組み

### PC/SCアーキテクチャ

PC/SC（Personal Computer/Smart Card）は、スマートカードリーダーと通信するための標準規格です。

```
アプリケーション (Node.js)
    ↓
pcsclite ライブラリ
    ↓
PC/SC サービス (pcsc-lite)
    ↓
PaSoRi リーダー (USB)
    ↓
Mifare カード
```

### カード読み取りの流れ

1. **リーダーの検出**
   - PC/SCサービスがPaSoRiリーダーを検出
   - `reader`イベントが発生

2. **カードの検出**
   - カードがリーダーに近づけられると`status`イベントが発生
   - `status.state`に`SCARD_STATE_PRESENT`フラグが設定される

3. **カードへの接続**
   ```javascript
   reader.connect({ share_mode: reader.SCARD_SHARE_SHARED }, (err, protocol) => {
       // 接続成功
   });
   ```

4. **ATR（Answer To Reset）の取得**
   - `status`イベントから`atr`プロパティを取得
   - ATRからカードタイプを判定

5. **UID（カードID）の取得**
   - Mifare Classicの場合: `0xFF 0xCA 0x00 0x00 0x00`コマンドを送信
   - レスポンスからUIDを抽出

6. **データベースへの保存**
   - 取得したUIDとカードタイプをSQLiteデータベースに保存

### コードの主要部分

#### カード検出
```javascript
reader.on('status', (status) => {
    const changes = this.readerStateChanges(reader, status);
    if (changes.inserted) {
        const atr = status.atr || null;
        this.handleCardInserted(reader, atr);
    }
});
```

#### UID取得
```javascript
// Mifare Classic用のUID取得コマンド
const getUIDCommand = Buffer.from([0xFF, 0xCA, 0x00, 0x00, 0x00]);

reader.transmit(getUIDCommand, 40, protocol, (err, data) => {
    if (data && data.length > 0) {
        const cardId = data.slice(0, 7).toString('hex').toUpperCase();
        // カードIDを取得
    }
});
```

## 解決した問題とその対処法

### 1. npm installの権限エラー

**問題:**
```
EPERM: operation not permitted
```

**解決策:**
- システム環境設定で「完全なディスクアクセス」にターミナルを追加
- npmキャッシュをクリアして再インストール

### 2. better-sqlite3のビルドエラー

**問題:**
```
C++20 or later required
```

**解決策:**
- `better-sqlite3`から`sqlite3`に変更
- `sqlite3`はより互換性が高く、ビルドが不要な場合が多い

### 3. pcscliteのAPIエラー

**問題:**
```
TypeError: reader.get_atr is not a function
TypeError: reader.status is not a function
```

**解決策:**
- `status`イベントから直接`atr`を取得
- `disconnect()`にコールバック関数を追加

### 4. カードIDの抽出

**問題:**
- レスポンスデータから正しくUIDを抽出する必要がある

**解決策:**
- レスポンスの最初の数バイト（通常4-7バイト）がUID
- 16進数文字列に変換して大文字化

## データベース構造

### cards テーブル

| カラム | 型 | 説明 |
|--------|-----|------|
| id | INTEGER | 主キー（自動増分） |
| card_id | TEXT | カードID（16進数、ユニーク） |
| card_type | TEXT | カードタイプ（Mifare Classic等） |
| read_at | TIMESTAMP | 読み取り日時 |
| created_at | TIMESTAMP | 登録日時 |

### データの例

```
ID: 1
card_id: CB9D24AE9000
card_type: Mifare Classic
read_at: 2026-01-16 00:12:34
created_at: 2026-01-16 00:12:34
```

## 使用方法

### アプリケーションの起動

```bash
npm start
```

または

```bash
node main.js
```

### メニュー操作

1. **カードを1回読み取る**: カードをリーダーに近づける
2. **連続してカードを読み取る**: 複数のカードを連続して読み取り
3. **データベース内のカード一覧を表示**: 保存されたカードの一覧を表示
4. **終了**: アプリケーションを終了

## 成功のポイント

1. **PC/SCアーキテクチャの採用**: macOSで安定して動作する標準規格を使用
2. **Node.js版への移行**: macOS Sequoiaでの互換性問題を回避
3. **適切なライブラリの選択**: `pcsclite`と`sqlite3`の組み合わせ
4. **エラーハンドリング**: 各段階での適切なエラー処理

## Webアプリケーションからの読み込み機能

### 実装概要

Webアプリケーション（`server/index.js`）から、このテストデータベース（`cards.db`）を読み込む機能を実装しました。

### 実装内容

#### 1. SQLite3の動的読み込み

```javascript
// SQLite3を動的にインポート（テストデータベースから読み込む場合）
let sqlite3 = null;
let sqlite3Loaded = false;

// SQLite3を非同期で読み込む
(async () => {
  try {
    const sqlite3Module = await import('sqlite3');
    sqlite3 = sqlite3Module.default || sqlite3Module;
    sqlite3Loaded = true;
    console.log('sqlite3を読み込みました。テストデータベースから読み込めます。');
  } catch (error) {
    console.warn('sqlite3がインストールされていません。テストデータベースからの読み込みは無効です。');
  }
})();
```

#### 2. テストデータベースからの読み込み関数

```javascript
const readCardsFromTestDatabase = async () => {
  // sqlite3がまだ読み込まれていない場合は待機
  if (!sqlite3Loaded) {
    // 最大5秒待機
    for (let i = 0; i < 50; i++) {
      await new Promise(resolve => setTimeout(resolve, 100));
      if (sqlite3Loaded) break;
    }
  }
  
  return new Promise((resolve, reject) => {
    if (!sqlite3) {
      resolve([]);
      return;
    }
    
    const testDbPath = path.join(__dirname, '../テストデータベース/cards.db');
    
    if (!fs.existsSync(testDbPath)) {
      console.warn('テストデータベースファイルが見つかりません:', testDbPath);
      resolve([]);
      return;
    }
    
    const Database = sqlite3.Database || sqlite3.default?.Database || sqlite3;
    const OPEN_READONLY = sqlite3.OPEN_READONLY || 1;
    
    const db = new Database(testDbPath, OPEN_READONLY, (err) => {
      if (err) {
        console.error('テストデータベース接続エラー:', err);
        resolve([]);
        return;
      }
    });
    
    db.all(
      'SELECT id, card_id, card_type, read_at, created_at FROM cards ORDER BY read_at DESC',
      [],
      (err, rows) => {
        db.close();
        if (err) {
          console.error('テストデータベース読み込みエラー:', err);
          resolve([]);
        } else {
          // 形式を統一
          const formattedCards = rows.map(row => ({
            id: row.id,
            card_id: row.card_id,
            user_id: null,
            registered_at: row.read_at || row.created_at,
            notes: row.card_type || null
          }));
          console.log(`テストデータベースから ${formattedCards.length} 件のカードを読み込みました`);
          resolve(formattedCards);
        }
      }
    );
  });
};
```

#### 3. APIエンドポイントの拡張

`/api/cards`エンドポイントを拡張し、JSONファイルとテストデータベースの両方からカード情報を取得します：

```javascript
app.get('/api/cards', async (req, res) => {
  try {
    // 現在のJSONファイルから読み込む
    const cardsFromJson = readCards();
    
    // テストデータベースからも読み込む
    const cardsFromTestDb = await readCardsFromTestDatabase();
    
    // マージ（重複を避ける）
    const allCards = [...cardsFromJson];
    const existingCardIds = new Set(cardsFromJson.map(c => c.card_id));
    
    cardsFromTestDb.forEach(card => {
      if (!existingCardIds.has(card.card_id)) {
        allCards.push(card);
        existingCardIds.add(card.card_id);
      }
    });
    
    res.json({
      success: true,
      cards: allCards.sort((a, b) => new Date(b.registered_at) - new Date(a.registered_at)),
      source: {
        json: cardsFromJson.length,
        testDatabase: cardsFromTestDb.length,
        total: allCards.length
      }
    });
  } catch (error) {
    console.error('カード一覧取得エラー:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'カード一覧の取得に失敗しました'
    });
  }
});
```

### 使用方法

1. **sqlite3パッケージのインストール**（まだの場合）:
   ```bash
   cd /Users/k.muto/webapp_01
   npm install sqlite3
   ```

2. **サーバーを起動**:
   ```bash
   npm start
   ```

3. **カード管理画面で確認**:
   - `admin`または`管理`でログイン
   - カード管理画面で、テストデータベースのカードも表示されます

### データ形式の統一

テストデータベースのデータ形式を、WebアプリケーションのJSON形式に統一しています：

| テストデータベース | Webアプリケーション |
|-------------------|-------------------|
| `id` | `id` |
| `card_id` | `card_id` |
| `card_type` | `notes` |
| `read_at` | `registered_at` |
| - | `user_id` (null) |

### エラーハンドリング

- `sqlite3`がインストールされていない場合: 警告を表示し、JSONファイルのみを使用
- データベースファイルが見つからない場合: 警告を表示し、空の配列を返す
- データベース接続エラー: エラーログを出力し、空の配列を返す

### メリット

1. **データの統合**: テストデータベースとWebアプリケーションのJSONファイルの両方からカード情報を取得
2. **重複の回避**: 同じ`card_id`を持つカードは重複して表示されない
3. **柔軟性**: `sqlite3`がインストールされていない場合でも、JSONファイルのみで動作
4. **データソースの可視化**: レスポンスに各ソースの件数を含めることで、データの出所を確認可能

## 今後の拡張可能性

1. **リアルタイム通知**: WebSocketを使用してカード読み取りをリアルタイムで通知
2. **統計機能**: 読み取り回数、頻度などの統計情報
3. **他のカードタイプ対応**: FeliCa、ISO14443等の他のカードタイプへの対応
4. **データベース同期**: テストデータベースとJSONファイルの自動同期機能

## 参考資料

- [PC/SC仕様](https://pcscworkgroup.com/)
- [pcsclite npmパッケージ](https://www.npmjs.com/package/pcsclite)
- [SQLite公式ドキュメント](https://www.sqlite.org/docs.html)
- [PaSoRi公式サイト](https://www.sony.co.jp/Products/felica/)

## まとめ

このプロジェクトでは、以下の技術とアプローチにより、Mifareカードの読み取りシステムを成功させました：

1. **PC/SC標準規格**を使用したカードリーダーアクセス
2. **Node.js + pcsclite**による安定した実装
3. **SQLiteデータベース**によるシンプルなデータ管理
4. **段階的な問題解決**による堅牢なシステム構築

システムは正常に動作し、カードIDを読み取ってデータベースに保存することができています。
