# 読み取りデータ形式

このシステムでMifareカードから読み取ることができたデータ形式をまとめています。

## 読み取り可能なデータ

### 1. ATR (Answer To Reset)

**説明**: カードがリーダーに接続された時に返される初期化データ

**実際の読み取り例**:
```
3B8F8001804F0CA000000306030001000000006A
```

**形式**:
- **データ型**: Buffer（バイナリデータ）
- **表示形式**: 16進数文字列（大文字）
- **長さ**: 約20-30バイト（カードタイプにより異なる）

**取得方法**:
```javascript
// statusイベントから取得
reader.on('status', (status) => {
    const atr = status.atr;  // Buffer形式
    const atrHex = atr.toString('hex').toUpperCase();  // 16進数文字列
});
```

**ATRの構造**:
- 最初のバイト: `3B` (TS - Initial character)
- 次のバイト: `8F` (T0 - Format byte)
- 以降: カード固有の情報

### 2. UID (Unique Identifier) / カードID

**説明**: カードの一意の識別子

**実際の読み取り例**:
```
CB9D24AE9000
```

**形式**:
- **データ型**: Buffer（バイナリデータ）
- **表示形式**: 16進数文字列（大文字）
- **長さ**: 4-7バイト（カードタイプにより異なる）
  - Mifare Classic: 通常4バイト（8文字の16進数）
  - Mifare Classic Extended: 7バイト（14文字の16進数）

**取得方法**:
```javascript
// PC/SCコマンドで取得
const getUIDCommand = Buffer.from([0xFF, 0xCA, 0x00, 0x00, 0x00]);
reader.transmit(getUIDCommand, 40, protocol, (err, data) => {
    const cardId = data.slice(0, 7).toString('hex').toUpperCase();
});
```

**コマンド詳細**:
- **コマンド**: `0xFF 0xCA 0x00 0x00 0x00`
  - `0xFF`: Class byte
  - `0xCA`: INS (Instruction) - Get Data
  - `0x00 0x00`: P1, P2 (Parameters)
  - `0x00`: Le (Expected length)

**レスポンス形式**:
- 成功時: `[UID bytes...] [0x90] [0x00]`
  - 最後の2バイト（`0x90 0x00`）は成功ステータス
  - その前のバイトがUID

### 3. カードタイプ

**説明**: 検出されたカードの種類

**実際の読み取り例**:
```
Mifare Classic
```

**形式**:
- **データ型**: 文字列
- **可能な値**:
  - `Mifare Classic`
  - `FeliCa`
  - `Unknown`

**判定方法**:
```javascript
detectCardType(atr) {
    const atrHex = atr.toString('hex').toUpperCase();
    
    // Mifare Classic
    if (atrHex.includes('3B8F8001804F0CA000000306030001000000006A')) {
        return 'Mifare Classic';
    }
    
    // FeliCa
    if (atrHex.includes('12FC') || atrHex.includes('01FE')) {
        return 'FeliCa';
    }
    
    return 'Unknown';
}
```

## データベースに保存される形式

### cards テーブル

| カラム | データ型 | 実際の値の例 | 説明 |
|--------|---------|-------------|------|
| id | INTEGER | 1 | 自動増分の主キー |
| card_id | TEXT | `CB9D24AE9000` | カードID（16進数文字列） |
| card_type | TEXT | `Mifare Classic` | カードタイプ |
| read_at | TIMESTAMP | `2026-01-16 00:12:34` | 読み取り日時 |
| created_at | TIMESTAMP | `2026-01-16 00:12:34` | 登録日時 |

### 保存時のデータ変換

```javascript
// 読み取りデータ
const atr = Buffer.from([0x3B, 0x8F, 0x80, ...]);  // ATR
const uid = Buffer.from([0xCB, 0x9D, 0x24, 0xAE, 0x90, 0x00]);  // UID

// データベースに保存する形式
const cardId = uid.toString('hex').toUpperCase();  // "CB9D24AE9000"
const cardType = detectCardType(atr);  // "Mifare Classic"
```

## 実際の読み取りデータ例

### 例1: Mifare Classicカード

```
=== カード検出 ===
リーダー: SONY FeliCa Port/PaSoRi 4.0
カードタイプ: Mifare Classic

=== ATR ===
Raw: <Buffer 3b 8f 80 01 80 4f 0c a0 00 00 03 06 03 00 01 00 00 00 00 6a>
Hex: 3B8F8001804F0CA000000306030001000000006A

=== UID ===
Raw: <Buffer cb 9d 24 ae 90 00>
Hex: CB9D24AE9000
Length: 6 bytes

=== データベース保存 ===
card_id: "CB9D24AE9000"
card_type: "Mifare Classic"
read_at: "2026-01-16 00:12:34"
```

### 例2: レスポンスデータの構造

**UID取得コマンドのレスポンス**:
```
送信コマンド: FF CA 00 00 00
受信レスポンス: CB 9D 24 AE 90 00 90 00
                |<-- UID -->| |Status|
```

- `CB 9D 24 AE 90 00`: UID（6バイト）
- `90 00`: 成功ステータス（SW1=0x90, SW2=0x00）

## データ形式の詳細

### 16進数文字列

**形式**: 大文字の16進数文字列
- 例: `CB9D24AE9000`
- 長さ: 8-14文字（4-7バイト）
- 区切り文字: なし

**変換方法**:
```javascript
// Buffer → 16進数文字列
const hex = buffer.toString('hex').toUpperCase();

// 16進数文字列 → Buffer
const buffer = Buffer.from(hex, 'hex');
```

### タイムスタンプ

**形式**: SQLiteのTIMESTAMP形式
- 例: `2026-01-16 00:12:34`
- 形式: `YYYY-MM-DD HH:MM:SS`
- タイムゾーン: システムのローカルタイムゾーン

**生成方法**:
```sql
-- SQLiteで自動生成
DEFAULT CURRENT_TIMESTAMP
```

## 読み取りプロセスのデータフロー

```
1. カード検出
   ↓
2. statusイベント発生
   status.atr = <Buffer 3b 8f 80 ...>
   ↓
3. カード接続
   reader.connect()
   ↓
4. UID取得コマンド送信
   [0xFF, 0xCA, 0x00, 0x00, 0x00]
   ↓
5. レスポンス受信
   <Buffer cb 9d 24 ae 90 00 90 00>
   ↓
6. UID抽出
   data.slice(0, 6) = <Buffer cb 9d 24 ae 90 00>
   ↓
7. 16進数文字列に変換
   "CB9D24AE9000"
   ↓
8. データベースに保存
   {
     card_id: "CB9D24AE9000",
     card_type: "Mifare Classic",
     read_at: "2026-01-16 00:12:34"
   }
```

## エラーハンドリング

### ATRが取得できない場合

```javascript
if (!atr || atr.length === 0) {
    console.log('ATRが取得できませんでした。代替方法を試します...');
    // 直接UID取得を試す
}
```

### UID取得コマンドが失敗した場合

```javascript
reader.transmit(getUIDCommand, 40, protocol, (err, data) => {
    if (err) {
        // ATRから情報を取得する代替方法
        this.tryAlternativeMethod(reader, protocol, atr);
        return;
    }
});
```

## データの検証

### UIDの妥当性チェック

```javascript
// UIDの長さチェック
if (data.length < 4 || data.length > 7) {
    console.warn('UIDの長さが不正です:', data.length);
    return;
}

// 16進数文字列の妥当性チェック
const hexPattern = /^[0-9A-F]{8,14}$/;
if (!hexPattern.test(cardId)) {
    console.warn('カードIDの形式が不正です:', cardId);
    return;
}
```

## まとめ

このシステムでは以下の形式でデータを読み取ることができます：

1. **ATR**: 20-30バイトのバイナリデータ（16進数文字列で表示）
2. **UID**: 4-7バイトのバイナリデータ（16進数文字列で表示）
3. **カードタイプ**: 文字列（"Mifare Classic"等）
4. **タイムスタンプ**: SQLite TIMESTAMP形式

すべてのデータは最終的にSQLiteデータベースに保存され、16進数文字列として扱われます。
